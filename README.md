# BLINK-ERRR  
*For how long a nice lady will be able to blink her eye on a CR2032 cell?*  
**Let's see!**

![board](img/board-01.png)

## Purpose of the project
_This project may or may not have any sense in the traditional sense of having a sense._ The project is the product of some sperimentation that lay between a **purely technical challenge** and **an artistic dimension**.

I got intrested in low power microcontroller stuff, and I wanted to do a simple little project to see for how long I could blink an led on a small battery, optimizing as much as I could. The specs i challenged myself to comply with were pretty easy:

- Blink an LED every 3-10 seconds;
- The blink should be at least visible outside without direct sunlight;
- The blink should be produced by a microcontroller;
- It should run as long as possible on a single CR2032 (obviously without removing power to the microcontroller);
- It should be the size and shape of a coin or little more.


In this form it remained for a long time just an idea in my drawer, until I found a nice way to express it to a non-technical audience. That was the point where i conceived BLINK-ERRR as we know it.  

## Artwork
While the concept for this project is mine, the artwork on the front of the board is a kind gift, courtesy of Francesca Ravasio. Kudos to her!

## Hardware
The hardware is based around an **ATtiny202**, one of the newest microcontroller in the ATtiny family. This microcontroller offers great low power performances, with the ability to run on the 32kHz oscillator and a **0.1uA** power down mode.  

 The original plan was to light the led with a square wave generated by the microcontroller, filtered through an LC lowpass passive filter, to not waste any power across a liming resistor. In the end, the square wave solution did not bring any advantage, so **the filter was removed and L1 was replaced with a resistor**.  

![schematic v1.0](img/schematic-v1.0-01.png)

## Firmware

### Toolchain and environment setup
I'm using MPLAB X with the AVR GCC toolchain installed.  
Installing the toolchain might be trivial if you have experience with MPLAB X, if not just follow these steps (for Windows):
- Download the avr GCC toolchain from Microchip [here](https://www.microchip.com/mplab/avr-support/avr-and-arm-toolchains-c-compilers).
- Extract the toolchain to a know path in your system. I've used `C:\Program Files (x86)\Microchip\avr-gcc`
- Open MPLAB X and go to Tools -> Options -> Embedded -> Build Tools -> Add...
- Select **the bin folder** in your avr-gcc folder.  

Now your toolchain should be set up.

### Firmware uploading
#### Programmers
The ATtiny202 uses the new UPDI inteface, for which i didn't have any programmer. There are a lot of options:
- **[jtag2updi](https://github.com/ElTangas/jtag2updi) (DIY / Arduino based)**: this is the DIY solution, you can upload this code to an Arduino Uno and use it as a programmer. This is the approach i've used. I'm not sure if this interface can be used for hardware debugging.
- **[MPLAB Snap](https://www.microchip.com/developmenttools/ProductDetails/PartNO/PG164100) (Cheapest official programmer)**: This is a new line of very cheap programmers by Microchip. It is very cheap but, beeing new, it has not a lot of support yet. There's little or no support for debugging.
- **[Atmel-ICE](https://www.microchip.com/DevelopmentTools/ProductDetails/ATATMEL-ICE) (Programmer and debugger)**: This is the traditional AVR programmer from Atmel. It's the most expensive in this list (about 120â‚¬), but it is also an hardware debugger.
- **[PICKit4](https://www.microchip.com/developmenttools/ProductDetails/PG164140) (Most universal)**: Probably the most universal programmer of all of these. It supports both AVR and PICS. It would be probably a better choice over the Atmel ICE, but i'm not sure of the PICKit hardware debug capabilities.
#### Uploading with jtag2updi and avrdude
As stated above, i've used the jtag2updi solution. The Author has provided a modified `avrdude.conf` file that can be passed to avrdude to add the support for the programmer and the UPDI compatible targets.  

I've uploaded it to an Arduino Uno using the Arduino IDE.
Contrary to what the author states, in my case **there was no need to cut or disable the auto-reset feature**, it works fine as is. I've connected the target to pin 6 of the Arduino and powered it with 5V from the Arduino board. The target mcu is connected to the arduino through three cables soldered directly on the pins going into the Arduino headers.  

I've used avrdude in the form of [AVRDUDESS](http://blog.zakkemble.net/avrdudess-a-gui-for-avrdude/) by Zak Kemble, a GUI for avrdude. You need to install it and replace the `avrdude.conf` file in the installation folder with the one found in the jtag2updi repo.

### chiedete a vb che io non lo so
